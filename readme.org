#+latex_class: cn-article
#+title: deepwaterooo deepwateroooMe -- I am the same GitHub account person
#+author: deepwaterooo 

* 要求
- Build an *employee directory app* that shows a list of employees from the provided endpoint.
- The app should display a list (or any kind of *collection view*!) which shows all the employees returned from the JSON endpoint described below. 
- Each item in the view should contain a *summary of the employee*, including their *photo, name, and team* at minimum. You may add more information to the summary if you want, or *sort employees in any fashion* you’d like – sort and group by name, team, etc.
  - 这个很好实现：加一个ListView的下拉列表框以提供可选择的排序标准；因为是MVVM设计，由数据来驱动UI,用户选择排序后，只需要操作viewModel里的链表按标准排序，并刷新UI就可以了，因为简单，不作这个项目的重点。
- There should be some UX to reload the employee list from within the app at any time. The UX can be done in any way you want: *a button, pull-to-refresh*, etc.
- If there is any additional UI/UX you would like to add, feel free to do so! We only ask that you please *do not build any more screens* than this list. Do not worry about building custom controls or UI elements – using *system-provided, standard elements* is totally fine.
- Be sure to *appropriately handle the normal variety of errors when querying an endpoint*. The app should *display useful loading, empty, and error states* where appropriate. *If images fail to load, displaying a placeholder* is fine.
  - *网络请求的异常处理* ：这个我想要把它作为项目的重中之重来处理
- One extra thing we ask is that you please ensure you *do not use more network bandwidth than necessary* – *load expensive resources such as photos on-demand only*.
  - *网络请求处理* ：在且仅在必要的时候网络请求
- The *employee list should not be persisted to disk*. You can reload it from the network *on each app launch and when refresh is requested* — but no more often than that unintentionally. 
- Android developers in particular should take care *not to make redundant network calls* when the *phone is rotated, or when memory is low*.
  - 旋转手机屏的时候，或手机内存低的时候，不能重新申请网络请求。就是 *转手机屏的时候，activity不能重建* ，只更改视图就可以了；(这个很容易就可以实现)
  - 当系统内存少，需要销毁acitivty并在必要时重建时(activity销毁前的数据保存)：之前没有搞懂数据库是起什么作用的，我把它删除了；但是现在看来，我还是需要使用数据库来在必要的时候保存链表数据的(另对图片的保存处理是否达到标准要求，还要再证实一下)
- *Images*, however, should *be cached on disk* so as to not waste device bandwidth. You may use an *open source image caching solution*, or write your own caching. Do not rely upon HTTP caching for image caching.
  - 这里 *需要测试一下，再想想要不要保存*
  - 我不担心这个，觉得Glide已经最大限度地优化了这个整个过程。只需要选对这个库就可以了
- Note that photos at a given URL will never change. Once one is loaded, you do not need to reload the photo. If an employee’s photo changes, they will be given a new photo URL.
  - *不懂这句话说的是什么意思，有什么影响？*
- *Tests should be provided for the app*. We do not expect 100% code coverage, so please use your best judgment for what should be tested. We’re also interested only in *unit tests*. Feel free to skip snapshot or app tests.
  - 不喜欢测试，但是这里可能 *需要加一两个测试用例*
- MVVM: 需要数据驱动，viewModel里定义一个状态变量，来标记当前的活动状态
- If any employee is malformed, it is fine to invalidate the entire list of employees in the response - there is no need to exclude only malformed employees.
- If there are no employees to show, the app should present an *empty state* view instead of an empty list. 

* 主要思路
- *对照它提示过/读得懂的要求，把自己可能会miss掉的小细节全捡回来*
- 现在重新再次整合Room数据库，把手机内存产资源不足时销毁activity保存数据的部分补充完整；
- 现在终于改掉了自己网址写错的小bug了，可以再往前迈进一步，深入深解拦截器与OkHttp底层的原理了。。。
- 顺着这个例子https://github.com/xitu/gold-miner/blob/master/TODO/getting-started-with-retrofit.md 把进阶的部分看完，弄懂
- 终于找到了先前 *今年二三月份参考过的一个很好的案例日志序列* ： MVVM https://blog.csdn.net/qq_38436214/category_11482619.html?spm=1001.2014.3001.5482
  - 下午忘记带一根测试用的线了，就暂时理一下思路，晚上回家后再在大电脑上测试
- 这是一个 *看似要求极其简单，实则考验的知识点和深度有着相当的跨度的小项目。*
- 它们一定挑都要挑我出差到WSU的一个星期里来考验我，因为他们就是想要去打败一个人。呵呵，真正想要打败一个人，谈何容易，就凭这？？？
- *Retrofit + RxJava*: 好像是更合适的，可以用注解，并且用得更为广泛
  - 搜索关键字：Retrofit + OkHttp +RxJava 网络库构建
  - *OkHttp*: 网络请求处理,主要是在应用启动的时候，什么时机开始发布和调用网络请求。所以这个可以不用了，大家都喜欢新的更好用的库
- *网络数据解析* ：我这里得到了网络数据，可是好像我并没有解析数据出来，这整个过程我可能还少了这比较关键的一个步骤
  - 当对这类框架和OOP设计有了更好的了解，就可以自定义解析类来在获得数据前自动解析为自己想要的类型
    - 注意这里提供的API其实并没有code msg之类的信息，而是直接的结果；再想一下：为什么OkHttp的拦截器能够得到code 200呢？这里Response返回基本信息还有点儿糊涂
    - 可以参考这个例子： https://developer.aliyun.com/article/609862
- *RxJava基本原理* ：RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.(一个通过使用可观察序列来组成异步的、基于事件的程序的库。)
  - 从介绍中我们可以提取出一个关键词：异步,但安卓中已经有很多解决异步操作的方法了，比如Handler和AsyncTask等, *为什么还选择RxJava呢，其实目的就是为了让代码更简洁，而且它的简洁是与众不同的，因为RxJava的使用方式是基于事件流的链式调用，这就保证了随着程序复杂性的提高，RxJava依然能保持代码的简洁和优雅* 。
- *图片本地缓存*: 第三方库找一个，还是用AndroidX的Room
  - 上面可能想错了，就是使用的第三方图片库Glide本身已经具备了缓存图片到本地的功能，所有我大可不必再多此一举，再来一个AndroidX Jetpack的Room数据库
  - 现将所有的room数据库相送的源码全部删除， *现只负责将RecyclerView的所有相送逻辑连通就可以了*
- 小问题：根据返回来数据的url链接来加载员工头像图片，可能并不需要我来实现什么网络请求的串接执行，更多应该是 *Recyclerview的双向数据绑定就可以了*
- 头像图片加载：现有两套思路，一套Mitch的MVVM但是非数据绑定的版本，一套双向数据绑定的自动化绑定的版本。
  - 按照项目的要求与缓存机制的要求，我觉得用Mitch的版本更为简洁，主要由第三方库Glide帮助缓存处理。自己需要必理的逻辑比较少，更简洁方便好用。 
  - 那么下面的这些关于缓存的问题都可以暂时不思考了，先运行起一个可以执行运行不出错的应用再说再优化。  
  - 我 *现在数据库的问题* 是：我 *缓存保存了员工数据进数据库* ，但是这里说得很清楚了， *不用保存员工数据，只保存每个员工id所对应的图片就可以了*
  - 说到网络缓存,肯定都不陌生，多多少少使用过不同的缓存方案。使用网络缓存有什么作用:
    - 减少服务器请求次数
    - 减少用户等待时间
    - 增加应用流畅度
    - 节省用户流量（虽然现在流量也不怎么值钱了）
- 应用的 *启动优化* ：重中之重，需要借助这个小应用弄懂弄清楚， *不知道如何拆解网络请求的步骤,什么时候加载，初始化之类的？* 以达到较好的启动优化
- 
- *MVVM设计* ：只有一个页面，相对就简单方便多了。工作中的案例是使用MVVM但自己编辑逻辑处理信号下发，与数据驱动的UI更新，没有实现双向数据绑定的；可是这里感觉 *双向数据绑定* 更简单，会有哪些可能的问题呢？这里基本可以当作不需要双向，因为一个UI按钮要求刷新是唯一的UI需求；更多的只是需要时候的数据往UI加载更新；所以 *可以简单使用观察者模式，UI观察数据的变化* 就可以了
- *图片的加载与处理* ：用样可以使用么第三方库 *glide*
- *图片的加载与处理* ：用样可以使用么第三方库 *CircularImageView*
- *AndroidX RecyclerView* 的使用：选择相对更为高效和方便管理的库和数据结构来使用
- *Constraint Layout vs Coordinate Layout*: 暂时先用任何简单的layout先能运行起一个大致的框架来，再进一步优化 
- 我丢掉了的文件呀，我写过的项目呀，不是在进Lucid之前写得好好的一个项目，现在源码全丢了。。。。。该死的GitHub.....
* OkHttp网络请求的缓存
- *OkHttpClient/Retrofit里在网络请求的时候(根据不同的url链接，或是不是请求接口？基于拦截器来做缓存)来动态使用不同的缓存策略(适用于自己只缓存图片，而不缓存员工链表)* ，这个思路应该用在这个项目的设计与实现里。原理参考这个思路： 
  - https://blog.csdn.net/c10WTiybQ1Ye3/article/details/125687902?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125687902-blog-51550400.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125687902-blog-51550400.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1
- 笔记本电脑上的kotlin-mode还没有配置好，改天配置好后再把这个部分的代码好好整理一下。早上时间紧张，暂时没时间来处理这个了 
#+BEGIN_SRC kotlin
private fun buildCacheKey(request: Request): String {
    val requestBody = request.body ?: return request.url.toString()
    val buffer = Buffer()
    requestBody.writeTo(buffer)

    val contentType = requestBody.contentType()
    val charset = contentType?.charset(Charsets.UTF_8) ?: Charsets.UTF_8

    if (isProbablyUtf8(buffer)) {
        val questParam = buffer.readString(charset)
        buffer.close()
        if (questParam.isBlank()) return request.url.toString()
        val builder = request.url.newBuilder()
        kotlin.runCatching {
            builder.addQueryParameter("${request.method.lowercase()}param", questParam)
            return builder.build().toString()
        }.onFailure {
            return ""
        }
    }
    return request.url.toString()
}

// 拦截器
// 我们在拦截器里做缓存，每次请求可能会是不同的策略，所以首先要拿到的就是缓存模式，
// 拿到缓存模式之后再根据不同的模式去读取或者写入操作，核心代码也就下边这几行：
override fun intercept(chain: Interceptor.Chain): Response {
    val initialRequest = chain.request()
    val strategy = CacheUtil.getCacheStrategy(initialRequest)
    val newRequest = initialRequest.rmCacheHeader()

    if (strategy == null) return chain.proceed(newRequest)// 策略为空，直接返回网络结果

    // ONLY_NETWORK 直接请求网络
    if (strategy.cacheMode == CacheMode.ONLY_NETWORK) return chain.proceed(newRequest)

    // ONLY_CACHE 只读取缓存
    if (strategy.cacheMode == CacheMode.ONLY_CACHE) {
        // 只读缓存模式,缓存为空,返回错误响应
        return (if (CacheManager.useExpiredData) mCache.getCache(strategy.cacheKey, newRequest)
                else redCache(strategy, newRequest)) ?: Response.Builder()
            .request(chain.request())
            .protocol(Protocol.HTTP_1_1)
            .code(HttpURLConnection.HTTP_GATEWAY_TIMEOUT)
            .message("no cached data")
            .body(EMPTY_RESPONSE)
            .sentRequestAtMillis(-1L)
            .receivedResponseAtMillis(System.currentTimeMillis())
            .build()
    }

    //先取缓存再取网络
    if (strategy.cacheMode == CacheMode.READ_CACHE_NETWORK_PUT) {
        val cacheResponse = redCache(strategy, newRequest)
        if (cacheResponse != null) return cacheResponse
    }

    try {
        // 开始请求网络
        val response = chain.proceed(newRequest)
        // 成功后写入缓存
        if (response.isSuccessful) {
            return cacheWritingResponse(mCache.putCache(strategy.cacheKey, response), response)
        }
        if (strategy.cacheMode == CacheMode.NETWORK_PUT_READ_CACHE) {
            return redCache(strategy, newRequest) ?: response
        }
        return response
    } catch (e: Throwable) {
        //请求失败尝试读取缓存，缓存没有或者失效，抛异常
        if (strategy.cacheMode == CacheMode.NETWORK_PUT_READ_CACHE) {
            return redCache(strategy, newRequest) ?: throw e
        }
        throw e
    }
}

// 设置缓存
// 这里不得不佩服 Retrofit 在解耦方面做的是真的强啊。我何时能有那样的思路跟想法呢。眼里只有崇拜~~~
// 言归正传 Retrofit 的请求头是在 Service里边添加的，所以添加缓存策略，直接写在Service里。
// Retrofit 两种添加请求头的方式@Headers 是方法注解，@Header 是参数注解。
// 再结合Kotlin 语法可以指定默认参数，如有不同缓存模式就可以在请求的时候，去动态使用不同缓存模式。
/**
 * 使用 Header 参数注解
 */
@FormUrlEncoded
@POST("user/login")
suspend fun login(
    @Field("username") username: String,
    @Field("password") password: String,
    @Header(CacheStrategy.CACHE_MODE) cacheMode: String = CacheMode.READ_CACHE_NETWORK_PUT,
    @Header(CacheStrategy.CACHE_TIME) cacheTime: String = "10"// 过期时间，10秒 不过期
): BaseResponse<Any>

/**
 * 使用 Headers 方法注解
 */
@Headers(
    "${CacheStrategy.CACHE_TIME}:-1", // 过期时间，-1 不过期
    "${CacheStrategy.CACHE_MODE}:${CacheMode.READ_CACHE_NETWORK_PUT}"
)
@GET("article/list/{page}/json")
suspend fun getPage(@Path("page") page: Any): BaseResponse<Page<ArticleBean>>

// 缓存的读写
// 读写操作还是用的OkHttp 的 DiskLruCache类。
// Okhttp 4.0.0 版本以后 就用 Kotlin 重构了。DiskLruCache 的构造函数被 internal 修饰了。
// 重构后的前几个版本还提供了 静态方法来创建。后边版本直接静态方法都移除了，这是要搞事情啊，不准备给我们用的样子。
// 不过如果用Java写的话就可以直接创建，Java会忽视 internal 关键字直接过编译期。但是 Kotlin 就不行了，会报错。
// 又不想用Java写。还是直接用反射创建吧，没有反射干不了的事情。
internal fun getDiskLruCache(
    fileSystem: FileSystem?,
    directory: File?,
    appVersion: Int,
    valueCount: Int,
    maxSize: Long
): DiskLruCache {
    val cls = DiskLruCache::class.java
    return try {
        val runnerClass = Class.forName("okhttp3.internal.concurrent.TaskRunner")
        val constructor = cls.getConstructor(
            FileSystem::class.java,
            File::class.java,
            Int::class.java,
            Int::class.java,
            Long::class.java,
            runnerClass
        )
        constructor.newInstance(
            fileSystem,
            directory,
            appVersion,
            valueCount,
            maxSize,
            TaskRunner.INSTANCE
        )
    } catch (e: Exception) {
        try {
            val constructor = cls.getConstructor(
                FileSystem::class.java,
                File::class.java,
                Int::class.java,
                Int::class.java,
                Long::class.java,
                Executor::class.java
            )
            val executor = ThreadPoolExecutor(
                0, 1, 60L, TimeUnit.SECONDS,
                LinkedBlockingQueue(), threadFactory("OkHttp DiskLruCache", true)
            )
            constructor.newInstance(
                fileSystem,
                directory,
                appVersion,
                valueCount,
                maxSize,
                executor
            )
        } catch (e: Exception) {
            throw IllegalArgumentException("Please use okhttp 4.0.0 or later")
        }
    }
}
// 刚好4.0.0 之后的几个版本，构造函数要提供一个线程池，4.3.0 后的版本成了 TaskRunner 了。可以都兼容一下。
// 具体的读写IO操作在CacheManager.kt 这个类中，这个是根据Okhttp 的 Cache 修改而来的。
// 全局参数
// 增加了全局 设置缓存模式、缓存时间。优先级还是 Service 中声明出来的高。
CacheManager.setCacheModel(CacheMode.READ_CACHE_NETWORK_PUT)// 设置全局缓存模式
    .setCacheTime(15 * 1000) // 设置全局 过期时间 (毫秒)
    .useExpiredData(true)// 缓存过期时是否继续使用，仅对 ONLY_CACHE 生效
// 具体使用方式:详见Demo NetCache： https://github.com/AleynP/net-cache
#+END_SRC 
- 现在的难点：不知道怎么定义图片数据库，同时以OkHTTP respnose回来的连接起来 (可以参考下面的一个例子，虽然MVVM的分工可能还不是很明确，但至少是一个可以运行的版本)

* 封装：OkHttp + EventBus
- EventBut是自己知识点面上的欠缺。借助这个极小的包装，打开一个通向真正理解这个OkHttp底层EventBus的道路。。。。
- event有5个类： *BaseEvent + HttpEvent + HttpSuccessEvent + HttpErrorEvent + AppEvent*
- *RequestTag*:请求tag
- *MainReqeust*:封装了OkHttp的回调，onResponse(...) onFailure(...)中用EventBus发送数据
- *UserRequest* ：请求网络数据的方法全部在里面，把OkHttp的前3步写在这里面，第4布封装在了MainRequest中
- *BaseActivity*:订阅事件总线，接收EventBus发送(post)的数据
** BaseEvent.java
   #+BEGIN_SRC csharp
public class BaseEvent {
    private int id;
    private String message;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
   #+END_SRC 
** HttpEvent
   #+BEGIN_SRC csharp
public class HttpEvent extends BaseEvent {
    @NonNull
        private RequestTag requestTag;
    public RequestTag getRequestTag() {
        return requestTag;
    }
    public void setRequestTag(@NonNull RequestTag requestTag) {
        this.requestTag = requestTag;
    }
}
   #+END_SRC 
** HttpSuccessEvent
   #+BEGIN_SRC csharp
public class HttpSuccessEvent extends HttpEvent {
    
    private String json;
    public String getJson() {
        return json;
    }
    public void setJson(String json) {
        this.json = json;
    }
}
   #+END_SRC 
** HttpErrorEvent
   #+BEGIN_SRC csharp
public class HttpErrorEvent extends HttpEvent {
    private int errorCode;
    private String errorMessage;
    public int getErrorCode() {
        return errorCode;
    }
    public void setErrorCode(int errorCode) {
        this.errorCode = errorCode;
    }
    public String getErrorMessage() {
        return errorMessage;
    }
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
}
   #+END_SRC 
** AppEvent
   #+BEGIN_SRC csharp
public class AppEvent extends BaseEvent {

    private Object obj1;
    private Object obj2;
    private String extraInfo = null;
    private String tag;
    private int code;
    public String getExtraInfo() {
        return extraInfo;
    }
    public void setExtraInfo(String extraInfo) {
        this.extraInfo = extraInfo;
    }
    public Object getObj1() {
        return obj1;
    }
    public void setObj1(Object obj) {
        this.obj1 = obj;
    }
    public Object getObj2() {
        return obj2;
    }
    public void setObj2(Object obj2) {
        this.obj2 = obj2;
    }
    public String getTag() {
        return tag;
    }
    public void setTag(String tag) {
        this.tag = tag;
    }
    public int getCode() {
        return code;
    }
    public void setCode(int code) {
        this.code = code;
    }
}
   #+END_SRC 
** RequestTag
   #+BEGIN_SRC csharp
public enum RequestTag {
    GET1,
    GET2,
    POST1,
    POST2,
}
   #+END_SRC 
** MainRequest
   #+BEGIN_SRC csharp
public class MainRequest {
    private static MainRequest mainRequest;
    private MainRequest() {
        super();
    }
    public static MainRequest getInstance() {
        if (mainRequest == null) {
            mainRequest = new MainRequest();
        }
        return mainRequest;
    }

    // 异步get
    public void makeAsyncGetRequest(Call call, final RequestTag tag) {
        call.enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    httpErrorEvent(e, tag);
                }
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    httpSuccessEvent(response.body().string(), tag);
                }
            });
    }
    // 同步get
    public void makeSyncGetRequest(final Call call, final RequestTag tag) {
        new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Response response = call.execute();
                        if (response.isSuccessful()) {
                            httpSuccessEvent(response.body().string(), tag);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                        httpErrorEvent(e, tag);
                    }
                }
            }).start();
    }
    // 异步post
    public void makeSyncPostRequest(Call call, final RequestTag tag) {
        call.enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    httpErrorEvent(e, tag);
                }
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    httpSuccessEvent(response.body().string(), tag);
                }
            });
    }
    // 同步post
    public void makeAsyncPostRequest(final Call call, final RequestTag tag) {
        new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Response response = call.execute();
                        if (response.isSuccessful()) {
                            httpSuccessEvent(response.body().string(), tag);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                        httpErrorEvent(e, tag);
                    }
                }
            }).start();
    }
    private void httpErrorEvent(IOException e, RequestTag tag) {
        Log.d("error", "error=" + e.getMessage().toString());
        HttpErrorEvent event = new HttpErrorEvent();
        event.setErrorMessage("" + e.getMessage().toString());
        event.setRequestTag(tag);
        EventBus.getDefault().post(event);
    }
    private void httpSuccessEvent(String json, RequestTag tag) {
        Log.d("response", "response=" + json);
        HttpSuccessEvent event = new HttpSuccessEvent();
        event.setJson(json);
        event.setRequestTag(tag);
        EventBus.getDefault().post(event);
    }
}
   #+END_SRC 
** UserRequest
- app中所有的请求都放在这个类中，类名比较随意，可以自己修改成AppRequest，比较好理解。
   #+BEGIN_SRC csharp
public class UserRequest {
    private OkHttpClient http;

    private UserRequest() {
        super();
        http = new OkHttpClient();
    }
    private static UserRequest userRequest;
    public static UserRequest getInstance() {
        if (userRequest == null) 
            userRequest = new UserRequest();
        return userRequest;
    }

    // get请求 不带参数
    //  同步get
    public void syncGet(String name, String pwd) {
        String url = "http:// 192.168.1.11:8080/okhttp/json1";
        RequestTag tag = RequestTag.GET1;
        Request request = new Request.Builder().url(url).get().build();
        Call call = http.newCall(request);
        MainRequest.getInstance().makeSyncGetRequest(call, tag);
    }
    // 异步get
    public void AsyncGet(String name, String pwd) {
        String url = "http:// 192.168.1.11:8080/okhttp/json2";
        RequestTag tag = RequestTag.GET2;
        Request request = new Request.Builder().url(url).get().build();
        Call call = http.newCall(request);
        MainRequest.getInstance().makeAsyncGetRequest(call, tag);
    }
    // 同步post
    public void syncPost(String name, String pwd) {
        String url = "http:// 192.168.1.11:8080/okhttp/json3";
        RequestTag tag = RequestTag.POST1;
        FormBody formBody = new FormBody.Builder().add("name", name).add("pwd", pwd).build();
        Request request = new Request.Builder().post(formBody).url(url).build();
        Call call = http.newCall(request);
        MainRequest.getInstance().makeSyncPostRequest(call, tag);
    }
    // 异步post
    public void AsyncPost(String name, String pwd) {
        String url = "http:// 192.168.1.11:8080/okhttp/json4";
        RequestTag tag = RequestTag.POST2;
        FormBody formBody = new FormBody.Builder().add("name", name).add("pwd", pwd).build();
        Request request = new Request.Builder().url(url).post(formBody).build();
        Call call = http.newCall(request);
        MainRequest.getInstance().makeAsyncPostRequest(call, tag);
    }
}
   #+END_SRC 
** BaseActivity
- 订阅事件，其余activity只需要继承即可
   #+BEGIN_SRC csharp
public class BaseActivity extends AppCompatActivity {
    private ProgressDialogUtil progressDialogUtil;
    @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EventBus.getDefault().register(this);
        progressDialogUtil = new ProgressDialogUtil(this);
    }
    @Override
        protected void onDestroy() {
        super.onDestroy();
        EventBus.getDefault().unregister(this);
    }

    @Subscribe(threadMode = ThreadMode.MAIN)
        public final void onEventBack(BaseEvent event) {
        if (event instanceof HttpErrorEvent) {
            // mark error
            httpErrorEvent((HttpErrorEvent) event);
        } else if (event instanceof HttpSuccessEvent) {
            httpSuccessEvent((HttpSuccessEvent) event);
        } else {
            applicationEvent((AppEvent) event);
        }
    }
    /**
     * 处理网络失败/错误请求
     * <p>直接判断HttpEvent的RequestTag即可
     * @param event 错误事件
     */
    public void httpErrorEvent(HttpErrorEvent event) {}
    /**
     * 处理网络成功请求
     * <p>直接判断HttpEvent的RequestTag即可
     * @param event 成功事件
     */
    public void httpSuccessEvent(HttpSuccessEvent event) {}
    /**
     * 处理app内部事件
     * @param event app内部事件
     */
    public void applicationEvent(AppEvent event) {}
    public void showToast(String message) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    }
    public void showProgressDialog() {
        progressDialogUtil.showDialog();
    }
    public void dismissProgressDialog() {
        progressDialogUtil.dismissDialog();
    }
}
   #+END_SRC 
** 使用封装
- 这样我们只需要调用一行代码就可以实现请求数据，提高了代码的简洁性。
#+BEGIN_SRC csharp
UserRequest.getInstance().AsyncPost("cui", "123456");
#+END_SRC 
- 重写这3个方法用于处理请求的数据
   #+BEGIN_SRC csharp
@Override
public void httpSuccessEvent(HttpSuccessEvent event) {
    super.httpSuccessEvent(event);
    if (event.getRequestTag() == RequestTag.GET1 || event.getRequestTag() == RequestTag.GET2
        || event.getRequestTag() == RequestTag.POST1 || event.getRequestTag() == RequestTag.POST2) {
        String json = event.getJson();
        tv.setText(json);
        //  TODO:  解析数据可以再写一个类JsonParser,将解析结果用EventBus发送过来，EventBus.getDefault().post(event);其中event是AppEvent
    }
}

@Override
public void httpErrorEvent(HttpErrorEvent event) {
    super.httpErrorEvent(event);
    if (event.getRequestTag() == RequestTag.GET1 || event.getRequestTag() == RequestTag.GET2
        || event.getRequestTag() == RequestTag.POST1 || event.getRequestTag() == RequestTag.POST2) {
        String json = event.getErrorMessage();
        tv.setText(json);
    }
}
@Override
public void applicationEvent(AppEvent event) {
    super.applicationEvent(event);
    //  TODO: 接收httpSuccessEvent(...)中JsonParser成功后发送的结果
}
   #+END_SRC 
** 怎么设置网络请求的缓存？
   #+BEGIN_SRC csharp
OkHttpClient client = new OkHttpClient.Builder()  
    .connectTimeout(5, TimeUnit.SECONDS)  
    .cache(new Cache(new File(this.getExternalCacheDir(), "okhttpcache"), 10 * 1024 * 1024))  
    .build();
   #+END_SRC 

* Retrofit
- 首先来了解下Retrofit是什么，在官网中对于Retrofit的描述是这样的：
  - A type-safe HTTP client for Android and Java.
  - 适用于Android和Java的类型安全的HTTP客户端。
  - 可以理解成一个封装好的网络请求库。
* room 数据库相关的部分: 几个相关可以用作参考的例子
** 另一个更好的参考例子： dagger + RecyclerView 和相应的 Adapters + BufferKnife View auto-injections
- https://github.com/SpikeKing/wcl-rx-cache-demo
- 这个 *设计思路可能显得相对过时了一点儿，四年前的仓库* ，应该还有很多更好的设计与实现，但仍然是一个非常值得自己参考与学习的仓库
- *没有使用room，而是直接操作安卓 SQLiteDatabase* ，具有上传数据的逻辑处理。所有弄懂了可以理解Room装填更为底层一点儿的原理
  - 如果最后时间不够用，又找不到更上层使用Room封装的案例用来参考学习，就可以回退到按照这个版本来参考实现
- *使用SwipeRefreshLayout来代替显示的刷新按钮* ，相比于我加上一个Button,显得更为方便好用elegant，可能会改变这个实现吧
- 这里一开始有个思想：是走本地有存储的路线，还是走本地没有存储的路线。所以，需要搞清楚，两个不同的路线之间是如何才能够动态切换的。另，这里是否涉及启动优化。Dagger的设计思想在这里的应用与主要作用是什么(Application layer ApiComponent原理目的等)？
  - 这里是无关设计思路，而是在两个按钮的点击回调里，分别指向本地有缓存或是本地无缓存的两条不同的路线逻辑，所以不用把问题想复杂或是把dagger想得太聪明了
- 这里网络数据的刷新与获取是在activity 的 onResume()里自动刷新并更新UI数据，MVVM用了吗分工明确了吗？仍然感觉不是很好
** ApiModule.java
   #+BEGIN_SRC csharp
/**
 * 模块
  */
@Module
public class ApiModule {
    private Application mApplication;

    public ApiModule(Application application) {
        mApplication = application;
    }

    @Provides @Singleton
    public Application provideApplication() {
        return mApplication;
    }

    @Provides @Singleton
    GitHubClient provideGitHubClient() {
        return new GitHubClient();
    }

    @Provides ObservableRepoDb provideObservableRepoDb() {
        return new ObservableRepoDb(mApplication);
    }
}
   #+END_SRC 
** ApiComponent.java
   #+BEGIN_SRC csharp
/**
 * 组件
 */
@Singleton @Component(modules = ApiModule.class)
public interface ApiComponent {
    void inject(NocacheActivity activity);
    void inject(CacheActivity activity);
}
   #+END_SRC 
** NocacheActivity extends Activity
#+BEGIN_SRC csharp
/**
 * 无缓存Activity
 * Created by wangchenlong on 16/1/18.
 */
public class NocacheActivity extends Activity {
    @Bind(R.id.nocache_rv_list) RecyclerView mRvList;
    @Bind(R.id.nocache_pb_progress) ProgressBar mPbProgress;
    @Inject Application mApplication;
    @Inject GitHubClient mGitHubClient;
    private ListAdapter mListAdapter;

    @Override protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_nocache);
        ButterKnife.bind(this);
        ((RcApplication) getApplication()).getApiComponent().inject(this);
        LinearLayoutManager layoutManager = new LinearLayoutManager(mApplication);
        mRvList.setLayoutManager(layoutManager);
        mListAdapter = new ListAdapter();
        mRvList.setAdapter(mListAdapter);
    }

    @Override protected void onResume() {
        super.onResume();
        // 延迟3秒, 模拟网络较差的效果
        mGitHubClient.getRepos("SpikeKing")
            .delay(3, TimeUnit.SECONDS)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(this::onSuccess, this::onError);
        mPbProgress.setVisibility(View.VISIBLE);
    }
    private void onSuccess(ArrayList<Repo> repos) {
        mListAdapter.setRepos(repos);
        mPbProgress.setVisibility(View.INVISIBLE);
    }
    private void onError(Throwable throwable) {
        mPbProgress.setVisibility(View.INVISIBLE);
    }
}
#+END_SRC 
** 这里有个小例子：
- https://github.com/Tom1881/Jet-pack/tree/master/app
- 但是我感觉上面的例子中，关于MVVM中的M, V, VM的分工逻辑处理得不好，dao不应该出现在view (activity/fragment)中，应该是在ViewModel或是Model中，应用是在数据的管理中， 而不是View/Ui中。

* Glide的缓存分为两种，Resource缓存、Bitmap缓存。
** 一、Resource缓存：
- 首先Resource缓存就是缓存整体的图片资源文件，缓存它是为了当首次从服务器端下载下来之后，缓存到本地，如果再次使用这个图片，不用去跑网络请求，直接从本地读取，节省流量也提高访问速度。它使用的是三级缓存原理：
  - 一级缓存：内存缓存，缓存被回收的资源，使用LRU算法（Least Frequently Used，最近最少使用算法），当需要再次使用到被回收的资源时，直接从内存中读取；
  - 二级缓存：使用弱引用缓存正在使用的资源，当系统执行GC操作时，会回收没有强引用的资源。使用弱引用缓存，既可以缓存当前正在强引用使用的资源，又不阻碍系统回收无引用的资源
  - 三级缓存：磁盘缓存，网络图片下载成功后，以文件的形式缓存到磁盘中
- 1和2都是内存缓存，只不过功能不一样，1是使用LRU算法缓存被GC回收的资源，2是用弱引用缓存正在使用的资源。在复用图片资源的时候首先从回收的内存缓存集合中查找，内存缓存的集合中没有的时候，去弱引用集合查找是否是当前正在使用，没有的话，去磁盘中查找，再没有的时候去网络中查找。
** 二、Bitmap缓存：Bitmap所占的内存大小由其三部分组成：图片宽，高和Bitmap质量参数。
- bitmap内存大小 = 宽*高*质量参数所占的位数，单位是字节b
  - ALPHA—8就是Alpha是由8位组成的（1B）
  - ARGB_4444，4个4位组成16位（2B）
  - ARGB_8888，4个8位组成32位（4B）
  - RGB_565，R是5位，G是6位，B是5位组成16位（2B），Glide默认bitmap压缩参数就是这个RGB_565，但是它不能显示透明度
- 先说一下为什么要进行bitmap压缩，比如在recycleView中加载大量的图片，频繁的创建和回收Bitmap会导致内存波动影响性能，既然这样，我们能不能缓存Bitmap，不要让它老是new和销毁，这应该是Glide去做Bitmap缓存的原因，
- Bitmap缓存算法：在Glide中使用BitmapPool来缓存Bitmap，使用的也是LRU算法（最近最少使用算法），当需要使用Bitmap时，先从Bitmap的池子中选取，如果找不到合适的Bitmap，再去创建，当使用完毕后，不再直接调用Bitmap.recycle()释放内存，而是缓存到Bitmap池子里。
- Bitmap的缓存是以键值对的方式进行缓存的，Resource和Bitmap都作为Value，而这些值是需要一个key来标识缓存的内容，根据key可以查找和移除对应的缓存。
* 下载图片并保存到本地： rxjava 2.x+retrofit 通过动态url保存网络图片到本地
  #+BEGIN_SRC csharp
// HttpManager 类：就是一个通过单例模式实现的类，获取retrofit的一个实例来调用NetApi接口内声明的方法，此处只写关键的一部分，别的相信你们都会
public <T> T getHttpApi(Class<T> service) {
    Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(BASE_URl)
        .client(getClient())
        .addConverterFactory(GsonConverterFactory.create())
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .build();

    return retrofit.create(service);
}
// BASE_URl 是你定义的域名比如：http://www.xxxx.com:8080之类的

// NetApi接口：
@GET
@Streaming
Observable<ResponseBody> downloadImg(@Url String  imgUrl);

// 注意注解：
// @GET后面不加任何东西，平时的都是@GET("api/getuserinfo")之类的和上面的那个BASE_URl拼接起来生成url：
// http://www.xxxx.com:8080/api/getuserinfo?请求条件=xx
// 然后去请求，这里采用@Url注解的方式就不用那么麻烦了
// @Url 此处是动态url即网络图片的url，需要从外部传入，如度娘图标url：
// https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png
// 用字符串的形式传入即可

// Presenter类 ：发起网络请求把得到的图片二进制流转化为bitmap对象，再通过bitmap对象保存到本地指定目录下
/**
 * 指定线程下载文件(异步)，非阻塞式下载
 * @param url       图片url
 * @param savePatch 下载文件保存目录
 * @param fileName  文件名称(不带后缀)
 */
public void downloadFile(String url, final String savePatch, final String fileName) {
    HttpManager.getInstance().getHttpApi(NetApi.class)
        .downloadImg(url)
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.newThread())
        .subscribe(new DisposableObserver<ResponseBody>() {
                @Override
                    public void onNext(ResponseBody responseBody) {
                    Bitmap bitmap = null;
                    byte[] bys;
                    try {
                        bys = responseBody.bytes();
                        bitmap = BitmapFactory.decodeByteArray(bys, 0, bys.length);

                        try {
                            FileUtils.saveImg(bitmap, savePatch, fileName);
                            String savePath = savePatch + File.separator + fileName + ".jpg";
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                    if (bitmap != null) {
                        bitmap.recycle();
                    }
                }
                @Override
                    public void onError(Throwable e) {
                    //你的处理
                }
                @Override
                    public void onComplete() {
                    //你的处理
                }
            });
}
// decodeByteArray是BitmapFactory内的方法，把二进制流转化为bitmap，需要导入系统包：
// import android.graphics.BitmapFactory;

// FileUtils类：IO操作，把图片保存到本地：
/**
 * 保存图片到SD卡
 * @param bm         图片bitmap对象
 * @param floderPath 下载文件保存目录
 * @param fileName   文件名称(不带后缀)
 */
public static void saveImg(Bitmap bm, String floderPath, String fileName) throws IOException {
    //如果不保存在sd下面下面这几行可以不加
    if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
        Log.e("SD卡异常");
        return;
    }
    File folder = new File(floderPath);
    if (!folder.exists()) {
        folder.mkdirs();
    }
    String savePath = folder.getPath() + File.separator + fileName + ".jpg";
    File file = new File(savePath);
    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));
    bm.compress(Bitmap.CompressFormat.JPEG, 80, bos);
    Log.d(savePath + " 保存成功");
    bos.flush();
    bos.close();
}
// 在你的service或者activity中调用：
mPresenter.downloadFile("https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png", Environment.getExternalStorageDirectory() + File.separator + "test", "baidu")
  #+END_SRC 

* 关于图片的处理：不仅要下载，下载后还需要自动保存到数据库
- https://blog.csdn.net/ANDROID_WangWeiDa/article/details/62284675
- 主要源码参考如下：
#+BEGIN_SRC csharp
/**
 * 观察者
 */
Observer<String> observer = new Observer<String>() {
    @Override
    public void onCompleted() {
        Log.e("TAG", "oncompleted()");
    }
    @Override
    public void onError(Throwable e) {
        Log.e("TAG", "onError()");
    }
    @Override
    public void onNext(String s) {
        Log.e("TAG", "onNext()" + s);
    }
};
// 或者创建观察者的实现类：Subscriber
/**
 * 观察者（观察者的实现类）
 */
Subscriber<String> subscriber = new Subscriber<String>() {
    @Override
    public void onCompleted() {
        Log.e("TAG", "oncompleted()");
    }
    @Override
    public void onError(Throwable e) {
        Log.e("TAG", "onError()");
    }
    @Override
    public void onNext(String s) {
        Log.e("TAG", "onNext()" + s);
    }
};
// 可以说，两者的效果是一样的。
// 接着创建可观察者（被观察者）Observable

/**
 * 可观察者（被观察者）
 */
Observable observale = Observable.create(new Observable.OnSubscribe<String>() {
        @Override
        public void call(Subscriber<? super String> subscriber) {
            subscriber.onNext("Hello");
            subscriber.onNext("My name is Avater!");
            subscriber.onCompleted();
        }
    });
// 好了，到此已经创建完毕，接着在onCreate方法中进行简单的调用：
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    observale.subscribeOn(Schedulers.io())  //订阅在io线程（非主线程），不会阻塞主线程
        .observeOn(AndroidSchedulers.mainThread())  //在主线程中观察
        .subscribe(observer);   //进行订阅关系
}
// Log:
// 03-15 12:06:45.837 2952-2952/com.avater.myapplication E/TAG: onNext()Hello
// 03-15 12:06:45.847 2952-2952/com.avater.myapplication E/TAG: onNext()My name is Avater!
// 03-15 12:06:45.847 2952-2952/com.avater.myapplication E/TAG: oncompleted()
// 是不是很快？是不是很懵逼？哈哈，这就对了，毕竟入门嘛，多实战，多理解！
// 下面附上一个使用Rxjava下载图片的例子：

private ImageView imageView;
private String url = "https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png";

/**
 * 图片观察者
 */
Observer<Bitmap> bitmapOberver = new Observer<Bitmap>() {
    @Override
    public void onCompleted() {

    }
    @Override
    public void onError(Throwable e) {
        Toast.makeText(MainActivity.this, "图片下载失败", Toast.LENGTH_SHORT).show();
    }
    @Override
    public void onNext(Bitmap bitmap) {
        imageView.setImageBitmap(bitmap);
    }
};

/**
 * 可观察者（被观察者）
 */
Observable<Bitmap> bitmapObservable = Observable.create(new Observable.OnSubscribe<Bitmap>() {
        @Override
        public void call(Subscriber<? super Bitmap> subscriber) {
            URL net;
            HttpURLConnection conn = null;
            InputStream inputStream = null;
            Bitmap bitmap = null;
            try {
                net = new URL(url);
                conn = (HttpURLConnection) net.openConnection();
                inputStream = conn.getInputStream();
                bitmap = BitmapFactory.decodeStream(inputStream);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                conn.disconnect();
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            subscriber.onNext(bitmap);
        }
    });
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    imageView = (ImageView) findViewById(R.id.imageview);

    bitmapObservable.subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(bitmapOberver);
}
#+END_SRC 

* 用Retrofit+Rxjava上传图片支持多张图片的上传
  #+BEGIN_SRC csharp
// 1.这是一个接口
@POST
Observable<ResponseBody> Image(@Url String url, @HeaderMap Map<String,Object> headermap,@Body MultipartBody body);
// 第一个是上传一个 第二个是上传多个

// 下面这个是一个Retrofit 封装好的工具类
public class Retrofits{
    private MyApiService myApiService;
    public Retrofits() {
        HttpLoggingInterceptor loggingInterceptor =new HttpLoggingInterceptor();
        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient okHttpClient =new OkHttpClient.Builder()
            .readTimeout(20,TimeUnit.SECONDS)
            .connectTimeout(20,TimeUnit.SECONDS)
            .writeTimeout(20,TimeUnit.SECONDS)
            .addInterceptor(loggingInterceptor)
            .retryOnConnectionFailure(true)
            .build();
        Retrofit retrofit =new Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create())
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
//                存放的头文件
            .baseUrl(Contacts.BASE_URL)
            .client(okHttpClient)
            .build();
        myApiService =retrofit.create(MyApiService.class);
    }
    public static  Retrofits getInstance(){
        return RetroHolder.OK_UTIL;
    }
    static class RetroHolder{
        private static final Retrofits OK_UTIL =new Retrofits ();
    }
    /**
     * 封装一个上传图片
     */
    public OkUtil image(String murl,Map<String,Object> headermap,Map<String,Object> map,List<Object> list){
        MultipartBody.Builder builder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        if (list.size()==1) {
            for (int i = 0; i < list.size(); i++) {
                File file = new File((String) list.get(i));
                builder.addFormDataPart("image", file.getName(),RequestBody.create(MediaType.parse("multipart/octet-stream"),file));
            }
        }
        myApiService.Image(murl,headermap,builder.build())
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(observer);
        return Retrofits.getInstance();
    }
    /**
     * 多个图片的上传
     */
    public OkUtil pinglun(String murl,Map<String,Object> headermap,Map<String,Object> map,List<Object> list){
        MultipartBody.Builder builder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        builder.addFormDataPart("commodityId",String.valueOf(map.get("commodityId")));
        if(!String.valueOf(map.get("orderId")).equals("")){
            builder.addFormDataPart("orderId",String.valueOf(map.get("orderId")));
        }
        builder.addFormDataPart("content",String.valueOf(map.get("content")));
        if (list.size()!=0) {
            for (int i = 1; i < list.size(); i++) {
                File file = new File((String) list.get(i));
                builder.addFormDataPart("image", file.getName(),RequestBody.create(MediaType.parse("multipart/octet-stream"),file));
            }
        }
        myApiService.Image(murl,headermap,builder.build())
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(observer);
        return Retrofits.getInstance();
    }
//    重写一个观察者模式
    private Observer observer =new Observer<ResponseBody>(){
        @Override
        public void onCompleted() {
        }
        @Override
        public void onError(Throwable e) {
            if(httpListener!=null){
                httpListener.onError(e.getMessage());
            }
        }
        @Override
        public void onNext(ResponseBody responseBody) {
            if(httpListener !=null){
                try {
                    httpListener.onSuccess(responseBody.string());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    };
    public interface HttpListener{
        void onSuccess(String gsonstr);
        void onError(String error);
    }
    private HttpListener httpListener;
    public void setHttpListener(HttpListener listener){
        this.httpListener =listener;
    }
}

// 一个方法把得到的图片路径 变为String类型
public String getFilePath(String fileName, int requestCode, Intent data) {
    if (requestCode == 1) {
        return fileName;
    } else if (requestCode == 0) {
        Uri uri = data.getData();
        String[] proj = {MediaStore.Images.Media.DATA};
        Cursor actualimagecursor = managedQuery(uri, proj, null, null, null);
        int actual_image_column_index = actualimagecursor
            .getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
        actualimagecursor.moveToFirst();
        String img_path = actualimagecursor
            .getString(actual_image_column_index);
        // 4.0以上平台会自动关闭cursor,所以加上版本判断,OK
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH)
            actualimagecursor.close();
        return img_path;
    }
    return null;
}

// 一个打开图库的方法
Intent intent1 = new Intent(Intent.ACTION_PICK);
intent1.setType("image/*");
startActivityForResult(intent1,0);

// 重写一个回调方法
@Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if(data==null){
        return;
    }
    if(requestCode==0){
        String filePath = getFilePath(null,requestCode,data);
        /**
         * 这里是用的一个图片的上传
         */
        Map<String, Object> map = new HashMap<>();
        List<Object> list =new ArrayList<>();
        list.add(filePath);
        pressent.image(Contacts.UploadYourHead, headermap, map,list,Register.class);
    }
}
  #+END_SRC 

* Android onSaveInstanceState()、onRestoreInstanceState()保存和恢复被系统销毁的数据
- Android系统的回收机制会在未经用户主动操作的情况下销毁activity，而为了避免系统回收activity导致数据丢失，Android为我们提供了onSaveInstanceState(Bundle outState)和onRestoreInstanceState(Bundle savedInstanceState)用于保存和恢复数据。
** 一、onSaveInstanceState(Bundle outState)在什么时机会被调用呢?
- 答案是 *当activity有可能被系统回收的情况下，而且是在onStop()之前(之前，确定吗？好像也有可能是之后呀，比如按HOME键后又立即从最近任务列表启动应用时，要不要再主证实一下 ？)* 。注意是 *有可能* ，如果是已经确定会被销毁，比如 *用户按下了返回键，或者调用了finish()方法销毁activity，则onSaveInstanceState不会被调用* 。 或者也可以说， *此方法只有在activity有可能被异常终止的情况下会被调用。*
- onSaveInstanceState 方法 ,onSave 方法的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据。
- Activity的销毁一般分为两种情况：
    - 当用户按返回按钮或你的Activity通过调用finish()销毁时，这属于正常销毁，此时是不需要恢复状态的，因为下次回来又是重新创建新的实例。
    - 如果Activity当前被停止或长期未使用，或者前台Activity需要更多资源以致系统必须关闭后台进程恢复内存，系统也可能会销毁Activity，这属于非正常销毁，尽管Activity实例被销毁，但系统会保存其状态，这样，如果用户导航回该Activity，系统会使用保存了该Activity被销毁时的状态数据来创建Activity的新实例。
- 屏幕旋转、键盘可用性改变、 语言改变都可以归结为第二种情况；
  - 值得一提的是，如果需要模拟这种情况的Activity销毁，可以打开开发者选项，选择不保留活动（英文为Do not keep activities），即可模拟内存不足时的系统行为。
- 总结下， *onSaveInstanceState* (Bundle outState)会在以下情况被调用：
    - 1、当用户按下HOME键时。 
    - 2、从最近应用中选择运行其他的程序时。 
    - 3、按下电源按键（关闭屏幕显示）时。 
    - 4、从当前activity启动一个新的activity时。 
    - 5、屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。
- 在前4种情况下，当前activity的生命周期为：
    - onPause -> onSaveInstanceState -> onStop。
- 这个是我测试的结果，但是 *根据《Android开发艺术探索》，说onPause和onSaveInstanceState的顺序是不一定的*
 
** 二、onRestoreInstanceState什么时机被调用?
- onRestoreInstanceState(BundlesavedInstanceState) *只有在activity确实是被系统回收，重新创建activity的情况下才会被调用。*
- 比如第5种情况屏幕方向切换时，activity生命周期如下： onPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume 在这里onRestoreInstanceState被调用，是因为屏幕切换时原来的activity确实被系统回收了，又重新创建了一个新的activity。 （顺便吐槽一下网上的那些文章说横屏切竖屏和竖屏切横屏时activity生命周期方法执行不一样，经自己实践证明是一样的。）
- 而按HOME键返回桌面，又马上点击应用图标回到原来页面时，activity生命周期如下： onPause -> onSaveInstanceState -> onStop -> onRestart -> onStart -> onResume 因为activity没有被系统回收，因此onRestoreInstanceState没有被调用。
  - 上面我自己测的onSaveInstanceState是在onStop之后： onPause() ==> onStop() ==> onSaveInstanceState() ==> onRestart() ==> onStart() ==> onResume()
- *如果onRestoreInstanceState被调用了，则页面必然被回收过，则onSaveInstanceState必然被调用过。*
** 三、onCreate()里也有Bundle参数，可以用来恢复数据，它和onRestoreInstanceState有什么区别?
- 因为onSaveInstanceState 不一定会被调用，所以 *onCreate()里的Bundle参数可能为空，如果使用onCreate()来恢复数据，一定要做非空判断。*
- 而 *onRestoreInstanceState的Bundle参数一定不会是空值* ，因为 *它只有在上次activity被回收了才会调用。*
- 而且onRestoreInstanceState是在onStart()之后被调用的。有时候我们需要onCreate()中做的一些初始化完成之后再恢复数据，用onRestoreInstanceState会比较方便。下面是官方文档对onRestoreInstanceState的说明：
  - This method is called after onStart() when the activity is being re-initialized from a previously saved state, given here in savedInstanceState. Most implementations will simply use onCreate(Bundle) to restore their state, but it is sometimes convenient to do it here after all of the initialization has been done or to allow subclasses to decide whether to use your default implementation.
  - 注意这个说明的最后一句是什么意思？ 
  - to allow subclasses to decide whether to use your default implementation.
- 它是说，用onRestoreInstanceState方法恢复数据，你可以决定是否在方法里调用父类的onRestoreInstanceState方法，即是否调用super.onRestoreInstanceState(savedInstanceState); 
  - 可是上面也有警告说：注意：您应始终调用 onRestoreInstanceState() 的父类实现，以便默认实现可以恢复视图层次结构的状态。所以这里要再搜索好好想一下
- 而用onCreate()恢复数据，你必须调用super.onCreate(savedInstanceState); 
#+BEGIN_SRC csharp
//保存和恢复数据
@Override
public void onSaveInstanceState(Bundle savedInstanceState) {
//可以把要保存的静态全局变量先转成Json
        savedInstanceState.putBoolean("MyBoolean", true);
        savedInstanceState.putDouble("myDouble", 1.9);
        savedInstanceState.putInt("MyInt", 1);
        savedInstanceState.putString("MyString", "Welcome back to Android");
        super.onSaveInstanceState(savedInstanceState);
}
  @Override
  public void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
// 从savedInstanceState中恢复数据,如果没有需要恢复数据savedInstanceState为nul 
      if (savedInstanceState != null) { // <<<<<<<<<<<<<<<<<<<<  非空判断
        boolean myBoolean = savedInstanceState.getBoolean("MyBoolean");
        double myDouble = savedInstanceState.getDouble("myDouble");
        int myInt = savedInstanceState.getInt("MyInt");
        String myString = savedInstanceState.getString("MyString");
      }
     }
//或在onRestoreInstanceState恢复数据
@Override
public void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState); // <<<<<<<<<< 这个可以调用，可以不用调用，随用户喜好 
        boolean myBoolean = savedInstanceState.getBoolean("MyBoolean");
        double myDouble = savedInstanceState.getDouble("myDouble");
        int myInt = savedInstanceState.getInt("MyInt");
        String myString = savedInstanceState.getString("MyString");
}
#+END_SRC  
* Library Hours
1. 34007 Alvarado-Niles Rd, *Union City*, CA 94587 (4.3 miles)
2. 37055 Newark Blvd, *Newark*, CA 94560 (5-7 miles)
3. 2400 Stevenson Blvd, *Fremont*, CA 94538 (太远了)
|---+--------+---------+----------+------------+----------+----------+------------|
|   | Sunday | Monday  | Tuesday  | Wednesday  | Thursday | Friday   | Saturday   |
|---+--------+---------+----------+------------+----------+----------+------------|
| 1 | Closed | *2–8PM* | 10AM–6PM | *10AM–6PM* | *2–8PM*  | *2–6PM*  | *10AM–5PM* |
| 2 | Closed | 12–8PM  | *12–8PM* | 10AM–6PM   | 10AM-6PM | Closed   | 10AM–5PM   |
| 3 | 1–5PM  | 12–8PM  | 12–8PM   | 11AM–6PM   | 11AM–6PM | 10AM–5PM | 10AM–5PM   |

* OkHttp Call 实现的简单案例: 最简单的小例子
- https://www.cnblogs.com/wjtaigwh/p/6210534.html
- 继这个最简单浅显的例子之后，可以借助https://blog.51cto.com/u_15456329/4799618 再深入理解一下，并按照别人的例子再实现一遍
** 简单的异步Get请求
  #+BEGIN_SRC csharp
// okHttp的基本使用 --- get方法
String url = "https:// api.douban.com/v2/movie/top250?start=0&count=10";
// 1,创建OKHttpClient对象
OkHttpClient mOkHttpClient = new OkHttpClient();
// 2,创建一个Request
Request request = new Request.Builder().url(url).build();
// 3,创建一个call对象
Call call = mOkHttpClient.newCall(request);
// 4,将请求添加到调度中
call.enqueue(new Callback() {
        @Override
        public void onFailure(Request request, IOException e) {
         }
         @Override
        public void onResponse(Response response) throws IOException {
            if (response.isSuccessful()) {
                final String message = response.body().string();
//  由于我们调用的enqueue（）方法，是运行在网络线程中的，
//  所以当我们得到json数据后想要获取更新UI的话，可以开使用handle.post()方法在run方法里面更新UI。                
                handler.post(new Runnable() { //  <<<<<<<<<<<<<<<<<<<<  将从网络请求的线程结果传到主线程上
                        @Override
                        public void run() {
                            tv_message.setText(message);
                            progressBar.setVisibility(View.GONE);
                        }
                    });
 
            }
        }
 
    });
  #+END_SRC 
** 简单的异步Post请求
- 这里的Post请求我们以最常见的注册登录来举例。post请求的步骤和get是相似的只是在创建Request的 时候将服务器需要的参数传递进去.
   #+BEGIN_SRC csharp
String url = "http:// 192.168.1.123:8081/api/login";
// 1,创建OKhttpClient对象
OkHttpClient mOkHttpClient = new OkHttpClient();
// 2,创建Request
RequestBody formBody = new FormEncodingBuilder() //  <<<<<<<<<< 
    .add("username", "superadmin")
    .add("pwd", "ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413")
    .build();
 
Request request = new Request.Builder().url(url).post(formBody).build(); //  <<<<<<<<<< 
// 3，创建call对象并将请求对象添加到调度中
mOkHttpClient.newCall(request).enqueue(new Callback() {
        @Override
        public void onFailure(Request request, IOException e) {
        }
        @Override
        public void onResponse(Response response) throws IOException {
            Log.i("wangjitao", response.body().string());
        }
    });   
#+END_SRC 
** OkHttp的封装
*** CallBack的创建　　
- 首选我们知道，当接口请求成功或者失败的时候我们需要将这个信息通知给用户，那么我们就需要创建一个抽象类RequestCallBack，请求前、成功、失败、请求后这几个方法，创建OnBefore（）、OnAfter（）、OnError（）、OnResponse（）对应
   #+BEGIN_SRC csharp
// 在请求之前的方法，一般用于加载框展示
// @param request
public void onBefore(Request request) {}
 
// 在请求之后的方法，一般用于加载框隐藏
public void onAfter() {}
 
// 请求失败的时候
// @param request
// @param e
public abstract void onError(Request request, Exception e);
 
// @param response
public abstract void onResponse(T response);
   #+END_SRC 
- 由于我们每次想要的数据不一定，所以这里我们用<T>来接收想要装成的数据格式，并通过反射得到想要的数据类型（一般是Bean、List）之类　，所以RequestCallBack的整体代码如下：
#+BEGIN_SRC csharp
// import com.google.gson.internal.$Gson$Types;
import com.squareup.okhttp.Request;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
 
/**
 * Created by wangjitao on 15/10/16.
 * 抽象类，用于请求成功后的回调
 */
public abstract class ResultCallback<T> {
    //这是请求数据的返回类型，包含常见的（Bean，List等）
    Type mType;
 
    public ResultCallback() {
        mType = getSuperclassTypeParameter(getClass());
    }
 
    /**
     * 通过反射想要的返回类型
     * @param subclass
     * @return
     */
    static Type getSuperclassTypeParameter(Class<?> subclass) {
        Type superclass = subclass.getGenericSuperclass();
        if (superclass instanceof Class) {
            throw new RuntimeException("Missing type parameter.");
        }
        ParameterizedType parameterized = (ParameterizedType) superclass;
        return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);
    }
 
    /**
     * 在请求之前的方法，一般用于加载框展示
     * @param request
     */
    public void onBefore(Request request) {}
 
    /**
     * 在请求之后的方法，一般用于加载框隐藏
     */
    public void onAfter() {}
 
    /**
     * 请求失败的时候
     * @param request
     * @param e
     */
    public abstract void onError(Request request, Exception e);
 
    /**
     * @param response
     */
    public abstract void onResponse(T response);
}
#+END_SRC 
*** 对Get、Post方法的简单封装　
- 首先我们创建一个OkHttpClientManager类，由于是管理类，所以，单例加静态对象搞起
#+BEGIN_SRC csharp
private static OkHttpClientManager mInstance;
public static OkHttpClientManager getInstance() {
    if (mInstance == null){
        synchronized (OkHttpClientManager.class) {
            if (mInstance == null) 
                mInstance = new OkHttpClientManager();
        }
    }
    return mInstance;
}
#+END_SRC 
- 在创建Manager对象的时候我们要把OkHttp的一些参数配置一下，顺便一提一下，由于我们我们异步get、post方法是运行在子线程中，所以这里我们添加了分发的 Handler mDelivery;，重写的OkHttpClientManager构造方法如下：
#+BEGIN_SRC csharp
private OkHttpClientManager() {
    mOkHttpClient = new OkHttpClient();
    mOkHttpClient.setConnectTimeout(10, TimeUnit.SECONDS);
    mOkHttpClient.setWriteTimeout(10, TimeUnit.SECONDS);
    mOkHttpClient.setReadTimeout(30, TimeUnit.SECONDS);
    //cookie enabled
    mOkHttpClient.setCookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER));
    mDelivery = new Handler(Looper.getMainLooper());
    mGson = new Gson();
}
#+END_SRC 
- 前面的外部调用对象封装好了，这里我们开始来封装Get或Post方法，我这里以Post方法为例子，首先分析一下，post方法会有几个参数，参数一url，参数二参数params，参数三Callback（及我们上面的RequestCallBack）参数四flag（用于取消请求操作，可为空），基础代码如下：
    #+BEGIN_SRC csharp
/**
 * 通用基础的异步的post请求
 * @param url
 * @param callback
 * @param tag
 */
public void postAsyn(String url, Param[] params, final ResultCallback callback, Object tag) {
    Request request = buildPostFormRequest(url, params, tag);
    deliveryResult(callback, request);
}
#+END_SRC 
- 那么我们再看一下deliveryResult方法到底是干什么的
#+BEGIN_SRC csharp
/**
 * 请求回调处理方法并传递返回值
 * @param callback Map类型请求参数
 * @param request Request请求
 */
private void deliveryResult(ResultCallback callback, Request request) {
    if (callback == null)
        callback = DEFAULT_RESULT_CALLBACK;
    final ResultCallback resCallBack = callback;
    // UI thread
    callback.onBefore(request);
    mOkHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(final Request request, final IOException e) {
                sendFailedStringCallback(request, e, resCallBack);
            }
            @Override
            public void onResponse(final Response response) {
                try {
                    final String responseMessage=response.message();
                    final String responseBody = response.body().string();
                    if(response.code()==200){
                        if (resCallBack.mType == String.class) {
                            sendSuccessResultCallback(responseBody, resCallBack);
                        } else {
                            Object o = mGson.fromJson(responseBody, resCallBack.mType);
                            sendSuccessResultCallback(o, resCallBack);
                        }
                    }else{
                        Exception exception=new Exception(response.code()+":"+responseMessage);
                        sendFailedStringCallback(response.request(), exception, resCallBack);
                    }
                } catch (IOException e) {
                    sendFailedStringCallback(response.request(), e, resCallBack);
                } catch (com.google.gson.JsonParseException e) {//Json解析的错误
                    sendFailedStringCallback(response.request(), e, resCallBack);
                }
            }
        });
}
    #+END_SRC 
- 可以看到，这个方法主要是发出请求并对请求后的数据开始回调，这样我们就基本上封装好了一个post方法了  ，把代码这一部分的代码贴出来看看
#+BEGIN_SRC csharp
public class OkHttpClientManager {
    private static final String TAG = "com.qianmo.httprequest.http.OkHttpClientManager";
 
    private static OkHttpClientManager mInstance;
    public static OkHttpClientManager getInstance() {
        if (mInstance == null) {
            synchronized (OkHttpClientManager.class) {
                if (mInstance == null) 
                    mInstance = new OkHttpClientManager();
            }
        }
        return mInstance;
    }

    // 默认的请求回调类
    private final ResultCallback<String> DEFAULT_RESULT_CALLBACK = new ResultCallback<String>(){
        @Override
        public void onError(Request request, Exception e) {}
        @Override
        public void onResponse(String response) {}
    };

    private OkHttpClient mOkHttpClient;
    private Handler mDelivery;
    private Gson mGson;
    private GetDelegate mGetDelegate = new GetDelegate();
    private PostDelegate mPostDelegate = new PostDelegate();
    private DownloadDelegate mDownloadDelegate = new DownloadDelegate();
 
    private OkHttpClientManager() {
        mOkHttpClient = new OkHttpClient();
        mOkHttpClient.setConnectTimeout(10, TimeUnit.SECONDS);
        mOkHttpClient.setWriteTimeout(10, TimeUnit.SECONDS);
        mOkHttpClient.setReadTimeout(30, TimeUnit.SECONDS);
        // cookie enabled
        mOkHttpClient.setCookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER));
        mDelivery = new Handler(Looper.getMainLooper());
        mGson = new Gson();
    }
 
    /**
     * 外部可调用的Post异步请求方法
     * @param url 请求url
     * @param params
     * @param callback 请求完成后回调类
     */
    public static void postAsyn(String url, Map<String, String> params, final ResultCallback callback) {
        getInstance().getPostDelegate().postAsyn(url, params, callback, null);
    }
 
    /**
     * 异步的post请求
     * @param url
     * @param params
     * @param callback
     * @param tag
     */
    public void postAsyn(String url, Map<String, String> params, final ResultCallback callback, Object tag) {
        Param[] paramsArr = map2Params(params);
        postAsyn(url, paramsArr, callback, tag);
    }
    /**
     * 通用基础的异步的post请求
     * @param url
     * @param callback
     * @param tag
     */
    public void postAsyn(String url, Param[] params, final ResultCallback callback, Object tag) {
        Request request = buildPostFormRequest(url, params, tag);
        deliveryResult(callback, request);
    }
     
    /**
     * 请求回调处理方法并传递返回值
     * @param callback Map类型请求参数
     * @param request Request请求
     */
    private void deliveryResult(ResultCallback callback, Request request) {
        if (callback == null)
            callback = DEFAULT_RESULT_CALLBACK;
        final ResultCallback resCallBack = callback;
        // UI thread
        callback.onBefore(request);
        mOkHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(final Request request, final IOException e) {
                    sendFailedStringCallback(request, e, resCallBack);
                }
                @Override
                public void onResponse(final Response response) {
                    try {
                        final String responseMessage=response.message();
                        final String responseBody = response.body().string();
                        if (response.code()==200){
                            if (resCallBack.mType == String.class) {
                                sendSuccessResultCallback(responseBody, resCallBack);
                            } else {
                                Object o = mGson.fromJson(responseBody, resCallBack.mType);
                                sendSuccessResultCallback(o, resCallBack);
                            }
                        } else{
                            Exception exception=new Exception(response.code()+":"+responseMessage);
                            sendFailedStringCallback(response.request(), exception, resCallBack);
                        }
                    } catch (IOException e) {
                        sendFailedStringCallback(response.request(), e, resCallBack);
                    } catch (com.google.gson.JsonParseException e) {// Json解析的错误
                        sendFailedStringCallback(response.request(), e, resCallBack);
                    }
                }
            });
    }
    /**
     * 处理请求成功的回调信息方法
     * @param object 服务器响应信息
     * @param callback 回调类
     */
    private void sendSuccessResultCallback(final Object object, final      ResultCallback callback) {
        mDelivery.post(() -> {
                callback.onResponse(object);
                callback.onAfter();
            });
    }
}    
#+END_SRC 

* 转屏等几种情况下activity的销毁与否，销毁与重建，数据保存
  - 横竖屏切换时候activity的生命周期：这个就打印日志再验证一遍吧。。。。。
#+BEGIN_SRC text
1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 
2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 
3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法
#+END_SRC 
  - 一般情况下Configuration的改变会导致Activity被销毁重建，但也有办法让指定的Configuration改变时不重建Activity，方法是在AndroidManifest.xml里通过android:configChanges属性指定需要忽略的Configuration名字，例如下面这样： 
#+begin_SRC xml
<activity 
　　android:name=".MyActivity" 
    android:configChanges="orientation|keyboardHidden|navigation|screenSize"
　　android:label="@string/app_name"/>
#+END_SRC 
  - 这样设置以后，当屏幕旋转时Activity对象不会被销毁——作为替代，Activity的onConfigurationChanged()方法被触发，在这里开发者可以获取到当前的屏幕方向以便做必要的更新。既然这种情况下的Activity不会被销毁，旋转后Activity里正显示的信息（例如文本框中的文字）也就不会丢失了。 
  -  假如你的应用里，横屏和竖屏使用同一个layout资源文件，onConfigurationChanged()里甚至可以什么都不做。但如果横屏与竖屏使用不同的layout资源文件，例如横屏用res/layout-land/main.xml，竖屏用res/layout-port/main.xml，则必须在onConfigurationChanged()里重新调用setContentView()方法以便新的layout能够生效，这时虽然Activity对象没有销毁，但界面上的各种控件都被销毁重建了，你需要写额外的代码来恢复界面信息。 
#+BEGIN_SRC csharp
@Override 
public void onConfigurationChanged(Configuration newConfig) { 
　　super.onConfigurationChanged(newConfig); 
 　　if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) 
　　　　Toast.makeText(this, "横屏模式", Toast.LENGTH_SHORT).show(); 
 　　else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)
　　　　Toast.makeText(this, "竖屏模式", Toast.LENGTH_SHORT).show(); 
}
#+END_SRC 
  - （注：官方不推荐使用这种方法。）
- 销毁当前的Activity：
  - 如果销毁当前的Activity，那么就要重写Activity的两个方法onSaveInstanceState（）和 onRestoreInstanceState（），显然从方法名字可以看出一个是保存
- 另一种保存-恢复现场的方法
  - 实现onRetainNonConfigurationInstance()方法保存数据，使用方法和前面的onSaveInstanceState(Bundle)差不多。
  #+BEGIN_SRC csharp
/*保存*/
 @Override 
public Object onRetainNonConfigurationInstance() { 
　　final MyDataObject data = collectMyLoadedData(); 
　　return data; 
} 
/*重建*/
@Override 
public void onCreate(Bundle savedInstanceState) { 
　　super.onCreate(savedInstanceState); 
　　setContentView(R.layout.main); 
　　final MyDataObject data = (MyDataObject) getLastNonConfigurationInstance(); 
　　if (data == null) // 表示不是由于Configuration改变触发的onCreate() 
　　　　data = loadMyData(); 
} 
  #+END_SRC 
 - activity的销毁和重建有时候不一定是由屏幕旋转引起的，所以还是建议使用保存-恢复现场的方法。

* Retrofit + RxJava + Json数据解析
- *网络数据解析* ：我这里得到了网络数据，可是好像我并没有解析数据出来，这整个过程我可能还少了这比较关键的一个步骤
  - 当对这类框架和OOP设计有了更好的了解，就可以自定义解析类来在获得数据前自动解析为自己想要的类型
    - 注意这里提供的API其实并没有code msg之类的信息，而是直接的结果；再想一下：为什么OkHttp的拦截器能够得到code 200呢？这里Response返回基本信息还有点儿糊涂
    - 可以参考这个例子： https://developer.aliyun.com/article/609862
  - 需要一个如下的步骤来解析从网络上拿到返回回来的数据
#+BEGIN_SRC csharp
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("http://www.kuaidi100.com/")
    .addConverterFactory(GsonConverterFactory.create())
    .build();
        
RetrofitService service = retrofit.create(RetrofitService.class);
Call<PostInfo> call = service.getPostInfo("yuantong", "11111111111");
call.enqueue(new Callback<PostInfo>() {
        @Override
            public void onResponse(Call<PostInfo> call, Response<PostInfo> response) {
            Log.i("http返回：", response.body().toString() + "");
        }
        @Override
            public void onFailure(Call<PostInfo> call, Throwable t) {
        }
    });
#+END_SRC 

* RxJava线程调度
- 在RxJava中，我们可以自行指定事件产生和事件消费的线程，可以通过RxJava中的Scheduler来实现。 Scheduler
** RxJava内置的5个Scheduler
- Schedulers. *immediate()*: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler，但是为了防止被错误使用，在RxJava2中已经被移除了。
- Schedulers. *newThread()*: 开启新线程，并在新线程执行操作。
- Schedulers. *io()*: I/O 操作（ *读写文件、读写数据库、网络信息交互等* ）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此 *多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。*
- Schedulers. *computation()*: 计算所使用的 Scheduler，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。
- Schedulers. *trampoline()*:主要用于延迟工作任务的执行。当我们想在当前线程执行一个任务时，但并不是立即，我们可以用.trampoline()将它入队，trampoline将会处理它的队列并且按序运行队列中每一个任务。
- Android特有的Scheduler
  - AndroidSchedulers. *mainThread()*:指定的操作将在Android的主线程中进行，如UI界面的更新操作。
** 线程的控制
- *subscribeOn():指定事件产生的线程* ，例如subscribeOn(Schedulers.io())可以指定被观察者的网络请求、文件读写等操作放置在io线程。
- *observeOn():指定事件消费的线程* ，例如observeOn(AndroidSchedulers.mainThread())指定Subscriber中的方法在主线程中运行。
- 在subscribe()之前写上两句subscribeOn(Scheduler.io())和observeOn(AndroidSchedulers.mainThread())的使用方式非常常见，它适用于多数的 <后台线程取数据，主线程显示> 的程序策略。

* 其它相对比较有参考价值的链接
- https://blog.51cto.com/u_15456329/4799618

